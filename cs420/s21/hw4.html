<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Homework 4</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{â€¦}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CS420:<span class="mywbr"> &nbsp;</span> Intro to Theory of Computation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="info.html" class="tocviewlink" data-pltdoc="x">Course Info</a></td></tr><tr><td align="right"></td><td><a href="logistics.html" class="tocviewlink" data-pltdoc="x">Logistics</a></td></tr><tr><td align="right"></td><td><a href="policies.html" class="tocviewlink" data-pltdoc="x">Course Policies</a></td></tr><tr><td align="right"></td><td><a href="lectureextra.html" class="tocviewlink" data-pltdoc="x">Lecture Extra</a></td></tr><tr><td align="right"></td><td><a href="hw0.html" class="tocviewlink" data-pltdoc="x">Homework 0</a></td></tr><tr><td align="right"></td><td><a href="hw1.html" class="tocviewlink" data-pltdoc="x">Homework 1</a></td></tr><tr><td align="right"></td><td><a href="hw2.html" class="tocviewlink" data-pltdoc="x">Homework 2</a></td></tr><tr><td align="right"></td><td><a href="hw3.html" class="tocviewlink" data-pltdoc="x">Homework 3</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Homework 4</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Homework 4</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._hw4-concat%29" class="tocviewlink" data-pltdoc="x">Concatentation</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._hw4-kleene%29" class="tocviewlink" data-pltdoc="x">Kleene Star</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._hw4-regexp%29" class="tocviewlink" data-pltdoc="x">A Regular Expression Matcher</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._hw4-reverse%29" class="tocviewlink" data-pltdoc="x">The FLIP Operation</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._hw4-pumping1%29" class="tocviewlink" data-pltdoc="x">A Non-<wbr></wbr>Regular language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._hw4-pumping2%29" class="tocviewlink" data-pltdoc="x">A Regular and a Non-<wbr></wbr>Regular Language</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._hw4-concat%29" class="tocsubseclink" data-pltdoc="x">Concatentation</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._hw4-kleene%29" class="tocsubseclink" data-pltdoc="x">Kleene Star</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._hw4-regexp%29" class="tocsubseclink" data-pltdoc="x">A Regular Expression Matcher</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._hw4-reverse%29" class="tocsubseclink" data-pltdoc="x">The FLIP Operation</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._hw4-pumping1%29" class="tocsubseclink" data-pltdoc="x">A Non-<wbr></wbr>Regular language</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._hw4-pumping2%29" class="tocsubseclink" data-pltdoc="x">A Regular and a Non-<wbr></wbr>Regular Language</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="hw3.html" title="backward to &quot;Homework 3&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CS420: Intro to Theory of Computation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3><a name="(part._hw4)"></a>Homework 4</h3><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><span class="emph">Last updated: </span>Fri, 19 Feb 2021 19:53:46 -0500</p></blockquote></blockquote></blockquote><p><span style="font-weight: bold">Out</span>: Mon Feb 22, 00:00 EST
<span style="font-weight: bold">Due</span>: Sun Feb 28, 23:59 EST</p><p>This is the last homework related to Chapter 1.</p><p>You will explore NFAs and their relation to regular expressions; an
additional closure property of regular langs; and
practice proving when a language is not regular.</p><p><span class="Larger"><span style="font-weight: bold">Homework Problems</span></span></p><ol><li><p><a href="#%28part._hw4-concat%29" data-pltdoc="x">Concatentation</a></p></li><li><p><a href="#%28part._hw4-kleene%29" data-pltdoc="x">Kleene Star</a></p></li><li><p><a href="#%28part._hw4-regexp%29" data-pltdoc="x">A Regular Expression Matcher</a> (8 pts + 4 pts bonus)</p></li><li><p><a href="#%28part._hw4-reverse%29" data-pltdoc="x">The FLIP Operation</a> (5 pts)</p></li><li><p><a href="#%28part._hw4-pumping1%29" data-pltdoc="x">A Non-Regular language</a> (5 pts)</p></li><li><p><a href="#%28part._hw4-pumping2%29" data-pltdoc="x">A Regular and a Non-Regular Language</a> (4 + 4 = 8 pts)</p></li></ol><p><span style="font-weight: bold">Total</span>: 26 points (+ 4 bonus points)</p><p><span class="Larger"><span style="font-weight: bold">Submitting</span></span></p><p><a href="policies.html#%28part._homework%29" data-pltdoc="x">Submit</a> the solution to this assignment in <a href="https://www.gradescope.com/courses/219302/assignments/1031326">Gradescope <span class="stt">hw4</span></a>.</p><p><div class="SIntrapara">The submission must include the following files (<span style="font-weight: bold">NOTE</span>: everything is case-sensitive):
</div><div class="SIntrapara"><ul><li><p><div class="SIntrapara">a <span class="stt">Makefile</span> with the following targets:
  </div><div class="SIntrapara"><ul><li><p><span class="stt">setup</span> (optional)</p></li><li><p><span class="stt">run-hw4-regexp</span></p></li></ul></div></p></li><li><p>a <span class="stt">README</span> containing <a href="policies.html#%28part._homework%29" data-pltdoc="x">the required information</a>,</p></li><li><p>the source code files needed by your <span class="stt">Makefile</span>,</p></li><li><p>and a pdf or plain-text file containing the answer to the non-coding questions.</p></li></ul></div></p><h4>1<tt>&nbsp;</tt><a name="(part._hw4-concat)"></a>Concatentation</h4><p><span class="Larger"><span style="font-weight: bold">Your Task</span></span></p><p>Implement concatentation for your NFAs. Specifically, write a function
that, given:</p><p><div class="SIntrapara"><ul><li><p>an NFA recognizing language <span class="texMathInline">A_1</span>, and</p></li><li><p>an NFA recognizing language <span class="texMathInline">A_2</span></p></li></ul></div><div class="SIntrapara">returns an NFA recognizing <span class="texMathInline">A_1 \circ A_2</span>.</div></p><p>To do this, you&rsquo;ll need to be able to extract individual
components of an NFA instance, e.g., the states, transitions, etc.</p><p><span style="font-weight: bold">NOTE</span>: When combining NFAs <span style="font-weight: bold">be careful with duplicate state
names</span>. Since the given files may use the same state names, it may be
a good idea to first rename them to something unique.</p><p>There will not be any direct tests for this problem.</p><h4>2<tt>&nbsp;</tt><a name="(part._hw4-kleene)"></a>Kleene Star</h4><p><span class="Larger"><span style="font-weight: bold">Your Task</span></span></p><p>Implement the Kleene Star operation for your NFAs. Specifically, write
a function that, given an NFA recognizing language <span class="texMathInline">A</span>, returns an
NFA recognizing <span class="texMathInline">A^*</span>.</p><p>To do this, you&rsquo;ll need to be able to extract individual
components of an NFA instance, e.g., the states, transitions, etc.</p><p>There will be not any direct tests for this problem.</p><h4>3<tt>&nbsp;</tt><a name="(part._hw4-regexp)"></a>A Regular Expression Matcher</h4><p>This problem will show you that you&rsquo;ve almost implemented (the core
of) a regular expression matcher, which is found in nearly every
programming language! Congrats!</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>The regexp matcher included
with most PLs are of course much more efficient, and have many more
bells and whistles than the theoretical models we are studying. But
the basic behavior is indeed the same.</p></blockquote></blockquote></blockquote><p>To complete it, you just need to combine your
<a href="hw3.html#%28part._hw3-datadef%29" data-pltdoc="x">NFA datastructure</a> from HW3, and the union,
concatenation, and Kleene star operations you implemented so far.</p><p>You will also need the definition (Def 1.52) of Regular
Expressions from the textbook:</p><p><div class="SIntrapara"><span class="texMathInline">R</span> is a <a name="(tech._regular._expression)"></a><span style="font-style: italic">regular expression</span> if <span class="texMathInline">R</span> is:
</div><div class="SIntrapara"><ul><li><p><span class="texMathInline">a</span> for some <span class="texMathInline">a\in</span> an alphabet <span class="texMathInline">\Sigma</span>,</p></li><li><p>the empty string <span class="texMathInline">\varepsilon</span>,</p></li><li><p>the empty set <span class="texMathInline">\emptyset</span>,</p></li><li><p><span class="texMathInline">R_1 \cup R_2</span>, sometimes written <span class="texMathInline">R_1\mid R_2</span>, where <span class="texMathInline">R_1</span> and <span class="texMathInline">R_2</span> are regular expressions,</p></li><li><p><span class="texMathInline">R_1 \circ R_2</span>, sometimes written <span class="texMathInline">R_1R_2</span>, where <span class="texMathInline">R_1</span> and <span class="texMathInline">R_2</span> are regular expressions,</p></li><li><p><span class="texMathInline">R_1^*</span>, where <span class="texMathInline">R_1</span> is a regular expression.</p></li></ul></div></p><p><span class="Larger"><span style="font-weight: bold">Your Task</span></span></p><p>Use Lemma 1.55 and the NFA closure operations you
implemented to create NFAs for each of the regular expressions
below (these are all from Example 1.53 in the textbook).</p><p>There are 12 examples total, but <span style="font-weight: bold">you only need to submit 8</span> to
get full credit (every example beyond 8 will be extra credit).</p><p>Assume that <span class="texMathInline">\Sigma = \{0,1\}</span>, a <span class="texMathInline">^+</span> means "1 or more", and a
<span class="texMathInline">\Sigma</span> in a regular expression below means <span class="texMathInline">0\cup 1</span>.</p><ol><li><p><span class="texMathInline">0^*10^* = \{w \mid w \textrm{ contains a single } 1\}</span></p></li><li><p><span class="texMathInline">\Sigma^*1\Sigma^* = \{w \mid w \textrm{ has at least one } 1\}</span></p></li><li><p><span class="texMathInline">\Sigma^*001\Sigma^* = \{w \mid w \textrm{ contains the string } 001 \textrm{ as a substring}\}</span></p></li><li><p><span class="texMathInline">1^*(01^+)^* = \{w \mid \textrm{every } 0 \textrm{ in } w \textrm{ is followed by at least one } 1\}</span></p></li><li><p><span class="texMathInline">(\Sigma\Sigma)^* = \{w \mid w \textrm{ is a string of even length}\}</span></p></li><li><p><span class="texMathInline">(\Sigma\Sigma\Sigma)^* = \{w \mid \textrm{the length of } w \textrm{ is a multiple of } 3\}</span></p></li><li><p><span class="texMathInline">01 \cup 10 = \{01,10\}</span></p></li><li><p><span class="texMathInline">0\Sigma^*0\cup 1\Sigma^*1\cup 0\cup 1 = \{w\mid w \textrm{ starts and ends with the same symbol}\}</span></p></li><li><p><span class="texMathInline">(0\cup\varepsilon)1^* = 01^*\cup1^*</span></p></li><li><p><span class="texMathInline">(0\cup\varepsilon)(1\cup\varepsilon) = \{\varepsilon,0,1,01\}</span></p></li><li><p><span class="texMathInline">1^*\emptyset = \emptyset</span></p></li><li><p><span class="texMathInline">\emptyset^* = \{\varepsilon\}</span></p></li></ol><p>To show you that each NFA you create is truly doing the same thing as
a real regexp matcher, the grader will test your submission using the
regexp implementation from an actual PL (e.g., could be Perl, Python,
Java, Racket, etc.).</p><p>Specifically, your solution will be tested as follows:</p><ul><li><p><span style="font-weight: bold">Input</span> (from <span class="stt">stdin</span>): a number, from 1 to
12 (inclusive), corresponding to one of the regular expression
examples from above</p></li><li><p>Expected <span style="font-weight: bold">Output</span> (to <span class="stt">stdout</span>): An XML
<a href="logistics.html#%28tech._automaton%29" class="techoutside" data-pltdoc="x"><span class="techinside">automaton</span></a> element representing an NFA that recognizes the
same language (for strings up to length 5) as the regular
expression corresponding to the input number.</p><p>To be correct, however, <span style="font-weight: bold">this NFA must have been constructed from
smaller NFAs using union, concat, and star as described in Lemma
1.55</span>. We will inspect your source code to ensure this.</p><p><div class="SIntrapara">To further illustrate what I mean, here is a snippet of (Racket) code from my solution:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename">Part of my solution, to illustrate what I want</span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(define N0 (single-char-nfa "0")) ; NFA recognizing {"0"}</span></p></td></tr><tr><td><p><span class="stt">(define N1 (single-char-nfa "1")) ; NFA recognizing {"1"}</span></p></td></tr><tr><td><p><span class="stt">(define N0* (nfa* N0)) ; NFA recognizing {"", "0", "00", "000", ...}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">(case (read-stdin)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">["1" (nfa-&gt;xml (nfa-concat (nfa-concat N0* N1) N0*))]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">....)</span></p></td></tr></table></blockquote></blockquote></div></p></li><li><p><span class="stt">Makefile</span> <span style="font-weight: bold">target name</span>: <span class="stt">run-hw4-regexp</span></p></li><li><p><span style="font-weight: bold">Example</span>:</p><p><span class="stt">printf "1" | make -sf Makefile run-hw4-regexp</span></p><p><div class="SIntrapara">Output:
  </div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">&lt;automaton&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="0" name="q164"&gt;&lt;initial/&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="1" name="N01"&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="2" name="N02"&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="3" name="N13178"&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="4" name="N14179"&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="5" name="q164180"&gt;&lt;final/&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="6" name="N01181"&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="7" name="N02182"&gt;&lt;final/&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;0&lt;/from&gt;&lt;to&gt;3&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;0&lt;/from&gt;&lt;to&gt;1&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;1&lt;/from&gt;&lt;to&gt;2&lt;/to&gt;&lt;read&gt;0&lt;/read&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;2&lt;/from&gt;&lt;to&gt;3&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;2&lt;/from&gt;&lt;to&gt;1&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;3&lt;/from&gt;&lt;to&gt;4&lt;/to&gt;&lt;read&gt;1&lt;/read&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;4&lt;/from&gt;&lt;to&gt;5&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;5&lt;/from&gt;&lt;to&gt;6&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;6&lt;/from&gt;&lt;to&gt;7&lt;/to&gt;&lt;read&gt;0&lt;/read&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;7&lt;/from&gt;&lt;to&gt;6&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;/automaton&gt;</span></p></td></tr></table></div></p></li></ul><p><span style="font-weight: bold">More Hints:</span></p><p>To further help you, below are the exact regexp patterns (each
corresponds to a numbered example from above) that the grader will use
with a regexp matcher to compare to your output NFA (the grader will
only check strings up to length 5).</p><p>Note that in typical regexp matching, a union of single chars, e.g.,
<span class="texMathInline">0 \cup 1</span>, is typically written <span class="stt">[01]</span>, while the "vertical
bar" <span class="texMathInline">\mid</span> is a more general union operation.</p><ol><li><p><span class="stt">"0*10*"</span></p></li><li><p><span class="stt">"[01]*1[01]*"</span></p></li><li><p><span class="stt">"[01]*001[01]*"</span></p></li><li><p><span class="stt">"1*(01+)*"</span></p></li><li><p><span class="stt">"([01][01])*"</span></p></li><li><p><span class="stt">"([01][01][01])*"</span></p></li><li><p><span class="stt">"01|10"</span></p></li><li><p><span class="stt">"0[01]*0|1[01]*1|0|1"</span></p></li><li><p><span class="stt">"01*|1*"</span></p></li><li><p><span class="stt">"^$|^0$|^1$|^01$"</span></p><p>(won&rsquo;t work without the <span class="stt">^</span> or <span class="stt">$</span>, which stand for "string start" and "string end", respectively, demonstrating that there <span class="emph">are</span> some differences between the theoretical regular expressions we study in class, and the regexp matching available in programming languages)</p></li><li><p><span class="stt">"\b\B"</span> (pattern that won&rsquo;t match anything)</p></li><li><p><span class="stt">""</span></p></li></ol><p>With these, you should be able to easily test your solution on your
own using the regexp library in your favorite language. Make sure to
choose "exact match" ("partial match" is the default in some langs and
will not recognize the same language), which corresponds to the
textbook&rsquo;s notion of matching.  Specifically, for any given string in
the language of alphabet <span class="texMathInline">\Sigma = \{0,1\}</span> (up to length 5), your
NFA should accept the string <span style="font-weight: bold">if and only if</span> the equivalent
regexp pattern matches on the string.</p><p>Finally, if you still need more explanations, the internet has
plenty of sites dedicated to learning about, and interactively
exploring regexps, e.g., <a href="https://regexr.com/">regexr.com</a>
or <a href="https://regex101.com/">regex101.com</a>.</p><h4>4<tt>&nbsp;</tt><a name="(part._hw4-reverse)"></a>The FLIP Operation</h4><p>Define the <span class="texMathInline">\textrm{FLIP}</span> operation on a language to be:</p><p><span class="texMathDisplay">\textrm{FLIP}(L) = \{c_n \ldots c_0 \mid c_0\ldots c_n \in L\}, \textrm{where } c_i \in \Sigma</span></p><p>Prove that regular languages are closed under the <span class="texMathInline">\textrm{FLIP}</span> operation.</p><p>You may use any proof style (e.g., proof by construction, proof by
induction, etc.) and may assume any theorems proven in class or the
book.</p><p>Also, you may use any representation of regular languages, e.g., DFA, NFA,
regexp, etc.</p><p>The proof must be submitted as either
a pdf or plain text file. Also, make sure to assign
it to the proper problem in Gradescope when submitting.</p><h4>5<tt>&nbsp;</tt><a name="(part._hw4-pumping1)"></a>A Non-Regular language</h4><p>Prove that the language <span class="texMathInline">L = \{www \mid w\in \{0,1\}^*\}</span> is not
regular.</p><h4>6<tt>&nbsp;</tt><a name="(part._hw4-pumping2)"></a>A Regular and a Non-Regular Language</h4><p>The language <span class="texMathInline">L_1 = \{a^nsa^n\mid n &gt; 0\textrm{ and }s\in\Sigma^*\}</span> is regular.</p><p>The language <span class="texMathInline">L_2 = \{a^nbsa^n\mid n &gt; 0\textrm{ and }s\in\Sigma^*\}</span>, however, is not regular.</p><p>You may assume <span class="texMathInline">\Sigma = \{a,b\}</span>.</p><ol><li><p>Prove that <span class="texMathInline">L_1</span> is regular.</p></li><li><p>Prove that <span class="texMathInline">L_2</span> is not regular.</p></li></ol><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="hw3.html" title="backward to &quot;Homework 3&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CS420: Intro to Theory of Computation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>