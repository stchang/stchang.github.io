<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Homework 3</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript">
(function() {
  document.write('<link rel="stylesheet" href="katex/katex.min.css" />');
})();(function() {document.write('<scr' + 'ipt type="text/javascript" src="katex/katex.min.js"></scr' + 'ipt>');})();(function(f) {
  // A "simple" onLoad function
  if (window.document.readyState == "complete") {
    f();
  } else if (window.document.addEventListener) {
    window.document.addEventListener("DOMContentLoaded", f, false);
  } else if (window.attachEvent) {
    window.attachEvent("onreadystatechange", function() {
      if (window.document.readyState == "complete") {
        f();
      }
    });
  } else {
    var oldLoad = window.onload;
    if (typeof(oldLoad) == "function") {
      window.onload = function() {
        try {
          oldLoad();
        } finally {
          f();
        }
      };
    } else {
      window.onload = f;
    }
  }
})(function() {
  // This is an ugly way to change the doctype, in case the scribble document
  // did not use (with-html5).
  if (!(document.doctype && document.doctype.publicId == '')) {
    if (console && console.log) {
      console.log("Re-wrote the document to use the HTML5 doctype.\n"
                  + "  Consider using the following declaration:\n"
                  + "      @title[#:style (with-html5 manual-doc-style)]{â€¦}");
    }
    var wholeDoc = '<!doctype HTML>\n' + document.documentElement.outerHTML;
    document.open();
    document.clear();
    document.write(wholeDoc);
  }
  var inlineElements = document.getElementsByClassName("texMathInline");
  for (var i = 0; i < inlineElements.length; i++) {
    var e = inlineElements[i];
    katex.render(e.textContent, e, { displayMode:false, throwOnError:false });
  }
  var displayElements = document.getElementsByClassName("texMathDisplay");
  for (var i = 0; i < displayElements.length; i++) {
    var e = displayElements[i];
    katex.render(e.textContent, e, { displayMode:true, throwOnError:false });
  }
});
</script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">CS420:<span class="mywbr"> &nbsp;</span> Intro to Theory of Computation</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="info.html" class="tocviewlink" data-pltdoc="x">Course Info</a></td></tr><tr><td align="right"></td><td><a href="logistics.html" class="tocviewlink" data-pltdoc="x">Logistics</a></td></tr><tr><td align="right"></td><td><a href="policies.html" class="tocviewlink" data-pltdoc="x">Course Policies</a></td></tr><tr><td align="right"></td><td><a href="lectureextra.html" class="tocviewlink" data-pltdoc="x">Lecture Extra</a></td></tr><tr><td align="right"></td><td><a href="hw0.html" class="tocviewlink" data-pltdoc="x">Homework 0</a></td></tr><tr><td align="right"></td><td><a href="hw1.html" class="tocviewlink" data-pltdoc="x">Homework 1</a></td></tr><tr><td align="right"></td><td><a href="hw2.html" class="tocviewlink" data-pltdoc="x">Homework 2</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Homework 3</a></td></tr><tr><td align="right"></td><td><a href="hw4.html" class="tocviewlink" data-pltdoc="x">Homework 4</a></td></tr><tr><td align="right"></td><td><a href="hw5.html" class="tocviewlink" data-pltdoc="x">Homework 5</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Homework 3</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._hw3-concat%29" class="tocviewlink" data-pltdoc="x">Concatentation</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._hw3-kleene%29" class="tocviewlink" data-pltdoc="x">Kleene Star</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._hw3-regexp%29" class="tocviewlink" data-pltdoc="x">A Regular Expression Matcher</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._hw3-reverse%29" class="tocviewlink" data-pltdoc="x">The Backwards Operation</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._hw3-pumping1%29" class="tocviewlink" data-pltdoc="x">A Non-<wbr></wbr>Regular language</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._hw3-pumping2%29" class="tocviewlink" data-pltdoc="x">A Regular and a Non-<wbr></wbr>Regular Language</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._hw3-concat%29" class="tocsubseclink" data-pltdoc="x">Concatentation</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._hw3-kleene%29" class="tocsubseclink" data-pltdoc="x">Kleene Star</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._hw3-regexp%29" class="tocsubseclink" data-pltdoc="x">A Regular Expression Matcher</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._hw3-reverse%29" class="tocsubseclink" data-pltdoc="x">The Backwards Operation</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._hw3-pumping1%29" class="tocsubseclink" data-pltdoc="x">A Non-<wbr></wbr>Regular language</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._hw3-pumping2%29" class="tocsubseclink" data-pltdoc="x">A Regular and a Non-<wbr></wbr>Regular Language</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="hw2.html" title="backward to &quot;Homework 2&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CS420: Intro to Theory of Computation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="hw4.html" title="forward to &quot;Homework 4&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h3><a name="(part._hw3)"></a>Homework 3</h3><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p><span class="emph">Last updated: </span>Wed, 30 Sep 2020 09:20:34 -0400</p></blockquote></blockquote></blockquote><p><span style="font-weight: bold">Out</span>: Wed Sept 30, 00:00 EST
<span style="font-weight: bold">Due</span>: Fri Oct 9, 23:59pm EST (<span style="font-weight: bold">Note</span>: extended deadline)</p><p>This is the last homework related to Chapter 1.</p><p>You will explore NFAs and their relation to regular expressions, an
additional closure property of regular langs, and
get practice distinguishing when a language is not regular.</p><p><span class="Larger"><span style="font-weight: bold">Homework Problems</span></span></p><ol><li><p><a href="#%28part._hw3-concat%29" data-pltdoc="x">Concatentation</a></p></li><li><p><a href="#%28part._hw3-kleene%29" data-pltdoc="x">Kleene Star</a></p></li><li><p><a href="#%28part._hw3-regexp%29" data-pltdoc="x">A Regular Expression Matcher</a></p></li><li><p><a href="#%28part._hw3-reverse%29" data-pltdoc="x">The Backwards Operation</a></p></li><li><p><a href="#%28part._hw3-pumping1%29" data-pltdoc="x">A Non-Regular language</a></p></li><li><p><a href="#%28part._hw3-pumping2%29" data-pltdoc="x">A Regular and a Non-Regular Language</a></p></li></ol><p><span class="Larger"><span style="font-weight: bold">Submitting</span></span></p><p><span style="font-weight: bold">Note</span>: This assignment has several <span style="font-weight: bold">non-code components</span>, e.g., see <a href="#%28part._hw3-reverse%29" data-pltdoc="x">The Backwards Operation</a>, <a href="#%28part._hw3-pumping1%29" data-pltdoc="x">A Non-Regular language</a>, or <a href="#%28part._hw3-pumping2%29" data-pltdoc="x">A Regular and a Non-Regular Language</a>.</p><ul><li><p><a href="policies.html#%28part._homework%29" data-pltdoc="x">Submit</a> the non-code part of this assignment at <a href="https://www.gradescope.com/courses/160337/assignments/694262">Gradescope <span class="stt">hw3</span> non-code</a>.</p><p>They must be pdf or plain text files and each file must be assigned to the correct problem in Gradescope.</p></li><li><p><a href="policies.html#%28part._homework%29" data-pltdoc="x">Submit</a> the code part of your solution to this assignment at <a href="https://www.gradescope.com/courses/160337/assignments/694257">Gradescope <span class="stt">hw3</span></a>.</p><p><div class="SIntrapara">The code submission must include the following files:
        </div><div class="SIntrapara"><ul><li><p><div class="SIntrapara">a <span class="stt">Makefile</span> with the following targets:
  </div><div class="SIntrapara"><ul><li><p><span class="stt">setup</span></p></li><li><p><span class="stt">run-hw3-regexp</span></p></li></ul></div></p></li><li><p>a <span class="stt">README</span> containing <a href="policies.html#%28part._homework%29" data-pltdoc="x">the required information</a>,</p></li><li><p>and the source code files needed by your <span class="stt">Makefile</span>.</p></li></ul></div></p></li></ul><h4>1<tt>&nbsp;</tt><a name="(part._hw3-concat)"></a>Concatentation</h4><p><span class="Larger"><span style="font-weight: bold">Your Task</span></span></p><p>Implement concatentation for your NFAs. Specifically, write a function
that, given:</p><p><div class="SIntrapara"><ul><li><p>an NFA recognizing language <span class="texMathInline">A_1</span>, and</p></li><li><p>an NFA recognizing language <span class="texMathInline">A_2</span></p></li></ul></div><div class="SIntrapara">returns an NFA recognizing <span class="texMathInline">A_1 \circ A_2</span>.</div></p><p>To do this, you&rsquo;ll need to be able to extract individual
components of an NFA instance, e.g., the states, transitions, etc.</p><p><span style="font-weight: bold">NOTE</span>: When combining NFAs <span style="font-weight: bold">be careful with duplicate state
names</span>. Since the given files may use the same state names, it may be
a good idea to first rename them to something unique.</p><p>There will not be any direct tests for this problem.</p><h4>2<tt>&nbsp;</tt><a name="(part._hw3-kleene)"></a>Kleene Star</h4><p><span class="Larger"><span style="font-weight: bold">Your Task</span></span></p><p>Implement the Kleene Star for your NFAs. Specifically, write a function
that, given an NFA recognizing language <span class="texMathInline">A</span>, returns an NFA recognizing <span class="texMathInline">A*</span>.</p><p>To do this, you&rsquo;ll need to be able to extract individual
components of an NFA instance, e.g., the states, transitions, etc.</p><p>There will be not any direct tests for this problem.</p><h4>3<tt>&nbsp;</tt><a name="(part._hw3-regexp)"></a>A Regular Expression Matcher</h4><p>Recall the formal definition (Def 1.52) of Regular Expressions from the textbook:</p><p><div class="SIntrapara"><span class="texMathInline">R</span> is a <a href="lectureextra.html#%28tech._regular._expression%29" class="techoutside" data-pltdoc="x"><span class="techinside">regular expression</span></a> if <span class="texMathInline">R</span> is:
</div><div class="SIntrapara"><ul><li><p><span class="texMathInline">a</span> for some <span class="texMathInline">a\in\textrm{alphabet }\Sigma</span>,</p></li><li><p>the empty string <span class="texMathInline">\varepsilon</span>,</p></li><li><p>the empty set <span class="texMathInline">\emptyset</span>,</p></li><li><p><span class="texMathInline">R_1 \cup R_2</span>, sometimes written <span class="texMathInline">R_1\mid R_2</span>, where <span class="texMathInline">R_1</span> and <span class="texMathInline">R_2</span> are regular expressions,</p></li><li><p><span class="texMathInline">R_1 \circ R_2</span>, sometimes written <span class="texMathInline">R_1R_2</span>, where <span class="texMathInline">R_1</span> and <span class="texMathInline">R_2</span> are regular expressions,</p></li><li><p><span class="texMathInline">R_1^*</span>, where <span class="texMathInline">R_1</span> is a regular expression.</p></li></ul></div></p><p>Following the proof of Lemma 1.55 from the textbook, you can use your
<a href="hw2.html#%28part._hw2-nfa%29" data-pltdoc="x">Data Representation for NFAs</a> from HW2, and the union, concatenation, and Kleene
star operations you implemented, to easily create an NFA
to match any regular expression!</p><p>In other words, you&rsquo;ve implemented the equivalent of the (core of the)
regular expression matcher found in nearly every programming language!
Congratulations! (The regexp matcher included with mature PLs are of
course much more efficient, and have many more bells and whistles than
the theoretical models we are studying. But the basic behavior is the same.)</p><p>To demonstrate this, use Lemma 1.55 and the NFA closure operations you
implemented to create NFAs for each of the regular expressions
below (these are all from Example 1.53 in the textbook).</p><p>There are 12 examples total, but <span style="font-weight: bold">you only need to submit 8</span> to
get full credit (every example beyond 8 will be extra credit).</p><p>Assume that <span class="texMathInline">\Sigma = \{0,1\}</span>, a <span class="texMathInline">^+</span> means "1 or more", and a
<span class="texMathInline">\Sigma</span> in a regular expression below means <span class="texMathInline">0\cup 1</span>.</p><ol><li><p><span class="texMathInline">0^*10^* = \{w \mid w \textrm{ contains a single } 1\}</span></p></li><li><p><span class="texMathInline">\Sigma^*1\Sigma^* = \{w \mid w \textrm{ has at least one } 1\}</span></p></li><li><p><span class="texMathInline">\Sigma^*001\Sigma^* = \{w \mid w \textrm{ contains the string } 001 \textrm{ as a substring}\}</span></p></li><li><p><span class="texMathInline">1^*(01^+)^* = \{w \mid \textrm{every } 0 \textrm{ in } w \textrm{ is followed by at least one } 1\}</span></p></li><li><p><span class="texMathInline">(\Sigma\Sigma)^* = \{w \mid w \textrm{ is a string of even length}\}</span></p></li><li><p><span class="texMathInline">(\Sigma\Sigma\Sigma)^* = \{w \mid \textrm{the length of } w \textrm{ is a multiple of } 3\}</span></p></li><li><p><span class="texMathInline">01 \cup 10 = \{01,10\}</span></p></li><li><p><span class="texMathInline">0\Sigma^*0\cup 1\Sigma^*1\cup 0\cup 1 = \{w\mid w \textrm{ starts and ends with the same symbol}\}</span></p></li><li><p><span class="texMathInline">(0\cup\varepsilon)1^* = 01^*\cup1^*</span></p></li><li><p><span class="texMathInline">(0\cup\varepsilon)(1\cup\varepsilon) = \{\varepsilon,0,1,01\}</span></p></li><li><p><span class="texMathInline">1^*\emptyset = \emptyset</span></p></li><li><p><span class="texMathInline">\emptyset^* = \{\varepsilon\}</span></p></li></ol><p>To show you that each NFA you create truly recognizes the same
language as a PL&rsquo;s regexp matcher, the grader will test your
submission using the regexp implementation from an actual PL (e.g.,
could be Perl, Python, Java, Racket, etc.).</p><p>Specifically, your solution will be tested as follows:</p><ul><li><p><span style="font-weight: bold">Input</span> (from <span class="stt">stdin</span>): a number, from 1 to
12 (inclusive), corresponding to one of the regular expression
examples from above</p></li><li><p>Expected <span style="font-weight: bold">Output</span> (to <span class="stt">stdout</span>): An XML
<a href="logistics.html#%28tech._automaton%29" class="techoutside" data-pltdoc="x"><span class="techinside">automaton</span></a> element representing an NFA that recognizes the
same language (for strings up to length 5) as the regular
expression corresponding to the input number.</p><p>To be correct, however, <span style="font-weight: bold">this NFA must have been constructed from
smaller NFAs using union, concat, and star as described in Lemma
1.55</span>. We will inspect your source code to ensure this.</p><p><div class="SIntrapara">To further illustrate what I mean, here is a snippet of (Racket) code from my solution:
</div><div class="SIntrapara"><blockquote class="Rfilebox"><p class="Rfiletitle"><span class="Rfilename"><span class="stt">"Part of my solution, to illustrate what I want"</span></span></p><blockquote class="Rfilecontent"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">(define N0 (single-char-nfa "0")) ; NFA recognizing {"0"}</span></p></td></tr><tr><td><p><span class="stt">(define N1 (single-char-nfa "1")) ; NFA recognizing {"1"}</span></p></td></tr><tr><td><p><span class="stt">(define N0* (nfa* N0)) ; NFA recognizing {"", "0", "00", "000", ...}</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;</span></p></td></tr><tr><td><p><span class="stt">(case (read-stdin)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">["1" (nfa-&gt;xml (nfa-concats N0* N1 N0*))]</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">....)</span></p></td></tr></table></blockquote></blockquote></div></p></li><li><p><span class="stt">Makefile</span> <span style="font-weight: bold">target name</span>: <span class="stt">run-hw3-regexp</span></p></li><li><p><span style="font-weight: bold">Example</span>:</p><p><span class="stt">printf "1" | make -sf Makefile run-hw3-regexp</span></p><p><div class="SIntrapara">Output:
  </div><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt">&lt;automaton&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="0" name="q164"&gt;&lt;initial/&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="1" name="N01"&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="2" name="N02"&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="3" name="N13178"&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="4" name="N14179"&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="5" name="q164180"&gt;&lt;final/&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="6" name="N01181"&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;state id="7" name="N02182"&gt;&lt;final/&gt;&lt;/state&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;0&lt;/from&gt;&lt;to&gt;3&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;0&lt;/from&gt;&lt;to&gt;1&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;1&lt;/from&gt;&lt;to&gt;2&lt;/to&gt;&lt;read&gt;0&lt;/read&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;2&lt;/from&gt;&lt;to&gt;3&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;2&lt;/from&gt;&lt;to&gt;1&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;3&lt;/from&gt;&lt;to&gt;4&lt;/to&gt;&lt;read&gt;1&lt;/read&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;4&lt;/from&gt;&lt;to&gt;5&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;5&lt;/from&gt;&lt;to&gt;6&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;6&lt;/from&gt;&lt;to&gt;7&lt;/to&gt;&lt;read&gt;0&lt;/read&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;transition&gt;&lt;from&gt;7&lt;/from&gt;&lt;to&gt;6&lt;/to&gt;&lt;read/&gt;&lt;/transition&gt;</span></p></td></tr><tr><td><p><span class="stt">&lt;/automaton&gt;</span></p></td></tr></table></div></p></li></ul><p><span style="font-weight: bold">More Hints:</span></p><p>To further help you, below are the exact regexp patterns (each
corresponds to a numbered example from above) that the grader will use
with a regexp matcher to compare to your output NFA (the grader will
only check strings up to length 5).</p><p>Note that in typical regexp matching, a union of single chars, e.g.,
<span class="texMathInline">0 \cup 1</span>, is typically written <span class="stt">[01]</span>, while the "vertical
bar" <span class="texMathInline">\mid</span> is a more general union operation.</p><ol><li><p><span class="stt">"0*10*"</span></p></li><li><p><span class="stt">"[01]*1[01]*"</span></p></li><li><p><span class="stt">"[01]*001[01]*"</span></p></li><li><p><span class="stt">"1*(01+)*"</span></p></li><li><p><span class="stt">"([01][01])*"</span></p></li><li><p><span class="stt">"([01][01][01])*"</span></p></li><li><p><span class="stt">"01|10"</span></p></li><li><p><span class="stt">"0[01]*0|1[01]*1|0|1"</span></p></li><li><p><span class="stt">"01*|1*"</span></p></li><li><p><span class="stt">"^$|^0$|^1$|^01$"</span></p><p>(won&rsquo;t work without the <span class="stt">^</span> or <span class="stt">$</span>, which stand for "string start" and "string end", respectively, demonstrating that there <span class="emph">are</span> some differences between the theoretical regular expressions we study in class, and the regexp matching available in programming languages)</p></li><li><p><span class="stt">"\b\B"</span> (pattern that won&rsquo;t match anything)</p></li><li><p><span class="stt">""</span></p></li></ol><p>With these, you should be able to easily test your solution on your
own using the regexp library in your favorite language. Make sure to
choose "exact match" ("partial match" is the default in some langs and
will not recognize the same language), which corresponds to the
textbook&rsquo;s notion of matching.  Specifically, for any given string in
the language of alphabet <span class="texMathInline">\Sigma = \{0,1\}</span> (up to length 5), your
NFA should accept the string <span style="font-weight: bold">if and only if</span> the equivalent
regexp pattern matches on the string.</p><p>Finally, if you still need more explanations, the internet has
plenty of sites dedicated to learning about, and interactively
exploring regexps, e.g., <a href="https://regexr.com/">regexr.com</a>
or <a href="https://regex101.com/">regex101.com</a>.</p><h4>4<tt>&nbsp;</tt><a name="(part._hw3-reverse)"></a>The Backwards Operation</h4><p>Define the Backwards (<span class="texMathInline">BW</span>) operation of a language to be <span class="texMathInline">BW(L) =
\{c_n \ldots c_0 \mid c_0\ldots c_n \in L\}, c_i \in \Sigma</span>.</p><p>Prove that regular languages are closed under the Backwards operation.</p><p>You may use any proof style (e.g., proof by construction, inductive
proofs) and may assume any theorems proven in class or the book.</p><p>Also, you may use any representation of regular languages, e.g., DFA, NFA,
regexp, etc.</p><p>You may write up your proof in any form but the submission must either
be a pdf or readable as plain text. Also, make sure you assign
it to the proper problem in Gradescope when submitting.</p><h4>5<tt>&nbsp;</tt><a name="(part._hw3-pumping1)"></a>A Non-Regular language</h4><p>Prove that the language <span class="texMathInline">L = \{www \mid w\in \{0,1\}^*\}</span> is not
regular.</p><h4>6<tt>&nbsp;</tt><a name="(part._hw3-pumping2)"></a>A Regular and a Non-Regular Language</h4><p>The language <span class="texMathInline">L_1 = \{a^nsa^n\mid n &gt; 0\textrm{ and }s\in\Sigma^*\}</span> is regular.</p><p>The language <span class="texMathInline">L_2 = \{a^nbsa^n\mid n &gt; 0\textrm{ and }s\in\Sigma^*\}</span>, however, is not regular.</p><p>You may assume <span class="texMathInline">\Sigma = \{a,b\}</span>.</p><ol><li><p>Prove that <span class="texMathInline">L_1</span> is regular.</p></li><li><p>Prove that <span class="texMathInline">L_2</span> is not regular.</p></li></ol><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="hw2.html" title="backward to &quot;Homework 2&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;CS420: Intro to Theory of Computation&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="hw4.html" title="forward to &quot;Homework 4&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>